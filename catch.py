import streamlit as st
import random
import time
from collections import deque
 
# ----------------------------- ÏÑ§Ï†ï ----------------------------- #
DIRECTIONS = ['UP', 'RIGHT', 'DOWN', 'LEFT']
DIRECTION_SYMBOLS = {'UP': '‚Üë', 'RIGHT': '‚Üí', 'DOWN': '‚Üì', 'LEFT': '‚Üê'}
MOVE_OFFSET = {'UP': (-1, 0), 'DOWN': (1, 0), 'LEFT': (0, -1), 'RIGHT': (0, 1)}
LEVELS = {
    "Level 1 (5Ï†ê, Ï∞©ÌïúÎßõ)": {"obstacles": 8, "score": 5, "ghost": False},
    "Level 2 (10Ï†ê, Î≥¥ÌÜµÎßõ)": {"obstacles": 14, "score": 10, "ghost": False},
    "Level 3 (20Ï†ê, Îß§Ïö¥Îßõ)": {"obstacles": 20, "score": 20, "ghost": False},
    "Level 4 (30Ï†ê, Î∂àÎã≠Îßõ)": {"obstacles": 24, "score": 30, "ghost": True, "ghost_range": 4, "ignore_obstacles": False},
    "Level 5 (50Ï†ê, ÌïµÎ∂àÎã≠Îßõ)": {"obstacles": 28, "score": 50, "ghost": True, "ghost_range": 3, "ignore_obstacles": True, "portals": True},
}
MAP_SIZE = 9
PORTAL_SYMBOL = 'üåÄ'

# ----------------------------- Ìï®Ïàò ----------------------------- #
def generate_map(obstacle_count, goal_count=2, use_portals=False):
    while True:
        positions = [(i, j) for i in range(MAP_SIZE) for j in range(MAP_SIZE)]
        start = random.choice(positions)
        positions.remove(start)

        obstacles = set(random.sample(positions, obstacle_count))
        positions = [p for p in positions if p not in obstacles]

        goals = random.sample(positions, goal_count)
        positions = [p for p in positions if p not in goals]

        portals = []
        if use_portals:
            portals = random.sample(positions, 2)

        if all(bfs_shortest_path(start, [g], obstacles) for g in goals):
            break

    return start, obstacles, goals, portals

def rotate(current_direction, rotation_command):
    idx = DIRECTIONS.index(current_direction)
    if rotation_command == "Ïò§Î•∏Ï™Ω ÌöåÏ†Ñ":
        return DIRECTIONS[(idx + 1) % 4]
    elif rotation_command == "ÏôºÏ™Ω ÌöåÏ†Ñ":
        return DIRECTIONS[(idx - 1) % 4]
    return current_direction

def move_forward(pos, direction, steps):
    for _ in range(steps):
        offset = MOVE_OFFSET[direction]
        pos = (pos[0] + offset[0], pos[1] + offset[1])
        if not (0 <= pos[0] < MAP_SIZE and 0 <= pos[1] < MAP_SIZE):
            return None
    return pos

def move_ghost(pos, target, obstacles, ignore_obstacles=False):
    dx, dy = target[0] - pos[0], target[1] - pos[1]
    options = []
    if dx != 0:
        options.append((pos[0] + (1 if dx > 0 else -1), pos[1]))
    if dy != 0:
        options.append((pos[0], pos[1] + (1 if dy > 0 else -1)))
    for opt in options:
        if 0 <= opt[0] < MAP_SIZE and 0 <= opt[1] < MAP_SIZE:
            if ignore_obstacles or opt not in obstacles:
                return opt
    return pos

def bfs_shortest_path(start, goals, obstacles):
    queue = deque([(start, [])])
    visited = {start}
    while queue:
        current, path = queue.popleft()
        if current in goals:
            return path
        for d in MOVE_OFFSET.values():
            nx, ny = current[0] + d[0], current[1] + d[1]
            next_pos = (nx, ny)
            if 0 <= nx < MAP_SIZE and 0 <= ny < MAP_SIZE and next_pos not in obstacles and next_pos not in visited:
                visited.add(next_pos)
                queue.append((next_pos, path + [next_pos]))
    return []

def draw_grid(position, direction, ghost, ghost_path, obstacles, goals, portals):
    grid = ""
    for i in range(MAP_SIZE):
        for j in range(MAP_SIZE):
            cell = '‚¨ú'
            if (i, j) == position:
                cell = 'ü§°'
            elif (i, j) in obstacles:
                cell = '‚¨õ'
            elif (i, j) in goals:
                cell = 'üéØ'
            elif (i, j) == ghost:
                cell = 'üëª'
            elif (i, j) in ghost_path:
                cell = '¬∑'
            elif (i, j) in portals:
                cell = PORTAL_SYMBOL
            grid += cell
        grid += '\n'
    st.text(grid)

# ----------------------------- Ïã§Ìñâ ----------------------------- #
st.title("ü§ñ Î°úÎ¥á Î™ÖÎ†π ÌçºÏ¶ê Í≤åÏûÑ")

st.markdown(
    """
    <audio autoplay loop>
        <source src="https://www.bensound.com/bensound-music/bensound-littleidea.mp3" type="audio/mpeg">
    </audio>
    """,
    unsafe_allow_html=True
)

if 'state' not in st.session_state:
    default_level = list(LEVELS.keys())[0]
    level_info = LEVELS[default_level]
    start, obstacles, goals, portals = generate_map(level_info['obstacles'], use_portals=level_info.get('portals', False))
    ghost = None
    if level_info['ghost']:
        ghost = (min(MAP_SIZE - 1, start[0] + level_info['ghost_range']), start[1])
    st.session_state.state = {
        'level': default_level,
        'start': start,
        'position': start,
        'direction': 'UP',
        'obstacles': obstacles,
        'goals': goals,
        'portals': portals,
        'ghost': ghost,
        'ghost_path': [],
        'score': 0,
        'high_score': 0,
        'total_score': 0,
        'result': '',
        'commands': []
    }
    st.session_state['command_input'] = ""

selected_level = st.selectbox("Î†àÎ≤® ÏÑ†ÌÉù", list(LEVELS.keys()))
if selected_level != st.session_state.state['level']:
    level_info = LEVELS[selected_level]
    start, obstacles, goals, portals = generate_map(level_info['obstacles'], use_portals=level_info.get('portals', False))
    ghost = None
    if level_info['ghost']:
        ghost = (min(MAP_SIZE - 1, start[0] + level_info['ghost_range']), start[1])
    st.session_state.state.update({
        'level': selected_level,
        'start': start,
        'position': start,
        'direction': 'UP',
        'obstacles': obstacles,
        'goals': goals,
        'portals': portals,
        'ghost': ghost,
        'ghost_path': [],
        'result': '',
        'commands': []
    })
    st.session_state["command_input"] = ""  # ‚úÖ Î™ÖÌôïÌïòÍ≤å Ï¥àÍ∏∞Ìôî

commands = st.text_area("Î™ÖÎ†πÏñ¥ ÏûÖÎ†•(ÌïúÏ§ÑÏóê Î™ÖÎ†πÏñ¥ ÌïòÎÇòÏî©)", value=st.session_state.get('command_input', ''))

if st.button("Ïã§Ìñâ"):
    s = st.session_state.state
    pos = s['position']
    direction = s['direction']
    ghost = s['ghost']
    ghost_path = []
    visited_goals = set()
    failed = False

    command_list = commands.strip().split('\n')
    for cmd in command_list:
        if cmd.startswith("ÏïûÏúºÎ°ú"):
            steps = int(cmd.split()[1]) if len(cmd.split()) > 1 else 1
            for _ in range(steps):
                temp_pos = move_forward(pos, direction, 1)
                if temp_pos is None or temp_pos in s['obstacles']:
                    s['result'] = '‚ùå Ïû•Ïï†Î¨º Ï∂©Îèå ÎòêÎäî Î≤Ω Î∞ñÏúºÎ°ú Î≤óÏñ¥ÎÇ®'
                    failed = True
                    break
                pos = temp_pos
        elif "ÌöåÏ†Ñ" in cmd:
            direction = rotate(direction, cmd)
        elif cmd == "ÏßëÍ∏∞" and pos in s['goals']:
            visited_goals.add(pos)

        if failed:
            break

        if ghost:
            ghost = move_ghost(ghost, pos, s['obstacles'], ignore_obstacles=LEVELS[s['level']].get('ignore_obstacles', False))
            ghost_path.append(ghost)
            if pos == ghost:
                s['result'] = 'üëª Í∑ÄÏã†ÏóêÍ≤å Ïû°Ìûò!'
                failed = True
                break

        draw_grid(pos, direction, ghost, ghost_path, s['obstacles'], s['goals'], s['portals'])
        time.sleep(0.3)

        if pos in s['portals']:
            dest = [p for p in s['portals'] if p != pos][0]
            around = [(dest[0] + d[0], dest[1] + d[1]) for d in MOVE_OFFSET.values()]
            random.shuffle(around)
            for a in around:
                if 0 <= a[0] < MAP_SIZE and 0 <= a[1] < MAP_SIZE:
                    pos = a
                    break

    if not failed:
        score = len(visited_goals) * LEVELS[s['level']]['score']
        s['score'] = score
        s['total_score'] += score
        s['high_score'] = max(s['high_score'], score)
        s['result'] = f"üéØ Î™©Ìëú ÎèÑÎã¨: {len(visited_goals)}Í∞ú, Ï†êÏàò: {score}"

        shortest = bfs_shortest_path(s['start'], s['goals'], s['obstacles'])
        if len(command_list) == len(shortest) + 2 and len(visited_goals) == 2:
            s['result'] += '\nüåü Perfect!'

    s.update({
        'position': pos,
        'direction': direction,
        'ghost': ghost,
        'ghost_path': ghost_path,
        'commands': command_list
    })
    st.session_state['command_input'] = '\n'.join(command_list)

st.markdown(f"**ÌòÑÏû¨ Ï†êÏàò:** {st.session_state.state['score']} / **ÏµúÍ≥† Ï†êÏàò:** {st.session_state.state['high_score']} / **ÎàÑÏ†Å Ï†êÏàò:** {st.session_state.state['total_score']}")
st.markdown(f"**Í≤∞Í≥º:** {st.session_state.state['result']}")

draw_grid(
    st.session_state.state['position'],
    st.session_state.state['direction'],
    st.session_state.state['ghost'],
    st.session_state.state['ghost_path'],
    st.session_state.state['obstacles'],
    st.session_state.state['goals'],
    st.session_state.state['portals']
)

if st.button("üîÅ Îã§Ïãú ÏãúÏûë"):
    level_info = LEVELS[st.session_state.state['level']]
    start, obstacles, goals, portals = generate_map(level_info['obstacles'], use_portals=level_info.get('portals', False))
    ghost = None
    if level_info['ghost']:
        ghost = (min(MAP_SIZE - 1, start[0] + level_info['ghost_range']), start[1])
    st.session_state.state.update({
        'start': start,
        'position': start,
        'direction': 'UP',
        'obstacles': obstacles,
        'goals': goals,
        'portals': portals,
        'ghost': ghost,
        'ghost_path': [],
        'result': '',
        'commands': []
    })
    st.session_state['command_input'] = ""

with st.expander("üìò Í≤åÏûÑ ÏÑ§Î™Ö Î≥¥Í∏∞"):
    st.markdown("""
    ### üéÆ Í≤åÏûÑ Î∞©Î≤ï
    Î°úÎ¥á ü§°ÏóêÍ≤å Î™ÖÎ†πÏñ¥Î•º ÏûÖÎ†•ÌïòÏó¨ Îëê Í∞úÏùò üéØ Î™©Ìëú ÏßÄÏ†êÏóê ÎèÑÎã¨ÌïòÍ≥† ÏßëÍ∏∞ Î™ÖÎ†πÏúºÎ°ú ÏàòÏßëÌïòÏÑ∏Ïöî!  
    Ïû•Ïï†Î¨º(‚¨õ)ÏùÑ ÌîºÌïòÍ≥†, Í∑ÄÏã†(üëª)ÏóêÍ≤å Ïû°ÌûàÏßÄ ÏïäÎèÑÎ°ù Ï°∞Ïã¨ÌïòÏÑ∏Ïöî!

    ### ‚úèÔ∏è ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Î™ÖÎ†πÏñ¥ (Í∏∞Î≥∏ Î∞©Ìñ• ÏúÑ)
    - Ìé∏ÏùòÎ•º ÏúÑÌïú ÏûêÎèôÏôÑÏÑ± Î™ÖÎ†πÏñ¥ Í∏∞Îä• Ï°¥Ïû¨
    - ÏïûÏúºÎ°ú : Ìïú Ïπ∏ Ï†ÑÏßÑ
    - ÏïûÏúºÎ°ú 2, ÏïûÏúºÎ°ú 3 : Ïó¨Îü¨ Ïπ∏ Ï†ÑÏßÑ
    - ÏôºÏ™ΩÏúºÎ°ú Ïù¥Îèô : ÏôºÏ™Ω Î∞©Ìñ•ÏúºÎ°ú 1Ïπ∏ Ïù¥Îèô
    - Ïò§Î•∏Ï™ΩÏúºÎ°ú Ïù¥Îèô : Ïò§Î•∏Ï™Ω Î∞©Ìñ•ÏúºÎ°ú 1Ïπ∏ Ïù¥Îèô
    - ÏßëÍ∏∞ : ÌòÑÏû¨ Ïπ∏Ïóê Î™©ÌëúÎ¨ºÏù¥ ÏûàÏùÑ Í≤ΩÏö∞ ÏàòÏßë

    ### üåÄ Ìè¨ÌÉà
    - Ìè¨ÌÉà(üåÄ)Ïóê Îì§Ïñ¥Í∞ÄÎ©¥ Îã§Î•∏ Ìè¨ÌÉà Í∑ºÏ≤ò ÎûúÎç§ ÏúÑÏπòÎ°ú ÏàúÍ∞Ñ Ïù¥Îèô
    - Í∑ÄÏã†ÏùÄ Ìè¨ÌÉàÏùÑ ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÏùå

    ### üëª Í∑ÄÏã†
    - Î†àÎ≤® 4: Í∑ÄÏã†ÏùÄ Ïû•Ïï†Î¨ºÏùÑ ÌîºÌï¥ÏÑú Ïù¥Îèô
    - Î†àÎ≤® 5: Í∑ÄÏã†ÏùÄ Ïû•Ïï†Î¨ºÏùÑ Î¨¥ÏãúÌïòÍ≥† ÏßÅÏßÑ Ï∂îÏ†Å

    ### üèÜ Perfect ÌåêÏ†ï
    - ÏµúÎã® Í≤ΩÎ°ú + Î™®Îì† Î™©Ìëú ÏàòÏßë + Î™ÖÎ†π Ïàò ÏµúÏÜåÏùº Îïå Perfect! üåü

    ### üß± Í∞Å Î†àÎ≤® Ï†ïÎ≥¥
    - Level 1 (5Ï†ê, Ï∞©ÌïúÎßõ): Ïû•Ïï†Î¨º 8Í∞ú, Í∑ÄÏã† ÏóÜÏùå
    - Level 2 (10Ï†ê, Î≥¥ÌÜµÎßõ): Ïû•Ïï†Î¨º 14Í∞ú, Í∑ÄÏã† ÏóÜÏùå
    - Level 3 (20Ï†ê, Îß§Ïö¥Îßõ): Ïû•Ïï†Î¨º 20Í∞ú, Í∑ÄÏã† ÏóÜÏùå
    - Level 4 (30Ï†ê, Î∂àÎã≠Îßõ): Ïû•Ïï†Î¨º 24Í∞ú, Í∑ÄÏã† 1Î™Ö
    - Level 5 (50Ï†ê, ÌïµÎ∂àÎã≠Îßõ): Ïû•Ïï†Î¨º 28Í∞ú, Í∑ÄÏã† 1Î™Ö, Ìè¨ÌÉà 2Í∞ú

    -Ïò§Î•ò Î∞úÍ≤¨Ïãú Î¨∏Ïùò
    """)

# üîä Î∞∞Í≤ΩÏùåÏïÖ ÏÇΩÏûÖ
st.markdown(
    """
    <audio autoplay loop>
        <source src="https://www.bensound.com/bensound-music/bensound-littleidea.mp3" type="audio/mpeg">
    </audio>
    """,
    unsafe_allow_html=True
)


# Î™ÖÎ†πÏñ¥ ÏûêÎèôÏôÑÏÑ± ÏòµÏÖò UI
auto_options = ["ÏïûÏúºÎ°ú", "ÏïûÏúºÎ°ú 2", "ÏïûÏúºÎ°ú 3", "ÏôºÏ™Ω ÌöåÏ†Ñ", "Ïò§Î•∏Ï™Ω ÌöåÏ†Ñ", "ÏßëÍ∏∞"]
selected_command = st.selectbox("ÏûêÎèôÏôÑÏÑ± Î™ÖÎ†πÏñ¥ ÏÑ†ÌÉù", auto_options)
if st.button("‚ûï Î™ÖÎ†πÏñ¥ Ï∂îÍ∞Ä"):
    current = st.session_state.get("command_input", "")
    new_value = (current + "\n" + selected_command).strip()
    st.session_state["command_input"] = new_value

# Î™ÖÎ†πÏñ¥ ÏûÖÎ†•Ï∞Ω (ÏûêÎèôÏôÑÏÑ±Í≥º Ïó∞Îèô)
commands = st.text_area("Î™ÖÎ†πÏñ¥ ÏûÖÎ†•(ÌïúÏ§ÑÏóê Î™ÖÎ†πÏñ¥ ÌïòÎÇòÏî©)",
                        value=st.session_state.get("command_input", ""),
                        key="command_input")

# ÏûÖÎ†• Î≥¥Ï†ï: "Ïïû" ‚Üí "ÏïûÏúºÎ°ú"
corrected_lines = []
for line in commands.strip().split('\n'):
    stripped = line.strip()
    if stripped == "Ïïû":
        corrected_lines.append("ÏïûÏúºÎ°ú")
    else:
        corrected_lines.append(stripped)
commands = "\n".join(corrected_lines)



# Í≤ΩÎ°ú ‚Üí Î™ÖÎ†πÏñ¥ Î≥ÄÌôò Ìï®Ïàò
def path_to_commands(path, initial_direction='UP'):
    commands = []
    direction = initial_direction

    for i in range(1, len(path)):
        cur = path[i - 1]
        nxt = path[i]
        dx, dy = nxt[0] - cur[0], nxt[1] - cur[1]

        # Ïù¥Îèô Î∞©Ìñ• Í≥ÑÏÇ∞
        for dir_name, (dx_offset, dy_offset) in MOVE_OFFSET.items():
            if (dx, dy) == (dx_offset, dy_offset):
                target_dir = dir_name
                break

def path_to_commands(path, initial_direction='UP'):
    commands = []
    direction = initial_direction

    for i in range(1, len(path)):
        cur = path[i - 1]
        nxt = path[i]
        dx, dy = nxt[0] - cur[0], nxt[1] - cur[1]

        for dir_name, (dx_offset, dy_offset) in MOVE_OFFSET.items():
            if (dx, dy) == (dx_offset, dy_offset):
                target_dir = dir_name
                break

        rotate_cmds = []
        orig_direction = direction  # ÌòÑÏû¨ Î∞îÎùºÎ≥¥Îäî Î∞©Ìñ• Ï†ÄÏû•

        while direction != target_dir:
            cur_idx = DIRECTIONS.index(direction)
            target_idx = DIRECTIONS.index(target_dir)
            if (target_idx - cur_idx) % 4 == 1:
                rotate_cmds.append("Ïò§Î•∏Ï™ΩÏúºÎ°ú Ïù¥Îèô")
                direction = rotate(direction, "Ïò§Î•∏Ï™Ω ÌöåÏ†Ñ")
            else:
                rotate_cmds.append("ÏôºÏ™ΩÏúºÎ°ú Ïù¥Îèô")
                direction = rotate(direction, "ÏôºÏ™Ω ÌöåÏ†Ñ")

        commands.extend(rotate_cmds)
        commands.append("ÏïûÏúºÎ°ú")

        # Î∞©Ìñ• Î≥µÏõê
        while direction != orig_direction:
            cur_idx = DIRECTIONS.index(direction)
            orig_idx = DIRECTIONS.index(orig_direction)
            if (orig_idx - cur_idx) % 4 == 1:
                commands.append("Ïò§Î•∏Ï™ΩÏúºÎ°ú Ïù¥Îèô")
                direction = rotate(direction, "Ïò§Î•∏Ï™Ω ÌöåÏ†Ñ")
            else:
                commands.append("ÏôºÏ™ΩÏúºÎ°ú Ïù¥Îèô")
                direction = rotate(direction, "ÏôºÏ™Ω ÌöåÏ†Ñ")

    commands.append("ÏßëÍ∏∞")
    return commands
# AI ÌûåÌä∏ Î≤ÑÌäº Ï≤òÎ¶¨
if st.button("\U0001f9e0 AI ÌûåÌä∏ Î≥¥Í∏∞ (-30Ï†ê)"):
    s = st.session_state.state

    if s['total_score'] < 30:
        st.warning("Ìè¨Ïù∏Ìä∏Í∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§! ÏµúÏÜå 30Ï†ê Ïù¥ÏÉÅ ÌïÑÏöîÌï¥Ïöî.")
    else:
        path = None
        for goal in s['goals']:
            path = bfs_shortest_path(s['position'], [goal], s['obstacles'])
            if path:
                break

        if not path:
            st.error("Í≤ΩÎ°úÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.")
        else:
            s['total_score'] -= 30
            ai_commands = path_to_commands([s['position']] + path, s['direction'])
            st.info("**AI Ï∂îÏ≤ú Î™ÖÎ†πÏñ¥:**\n\n" + '\n'.join(ai_commands))

 
